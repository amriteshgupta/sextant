{"ast":null,"code":"'use strict';\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0x00) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // overlong\n      ) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||\n      // overlong\n      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||\n      // overlong\n      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nmodule.exports = isValidUTF8;","map":{"version":3,"names":["isValidUTF8","buf","len","length","i","module","exports"],"sources":["C:/Users/AMRITESH/OneDrive - Babu Banarasi Das National Institute of Technology and Management/Documents/Workspace/ReactJs/sextant/node_modules/utf-8-validate/fallback.js"],"sourcesContent":["'use strict';\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0x00) {  // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {  // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0  // overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {  // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 ||  // overlong\n        buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0  // surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {  // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 ||  // overlong\n        buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4  // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = isValidUTF8;\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAWA,CAACC,GAAG,EAAE;EACxB,MAAMC,GAAG,GAAGD,GAAG,CAACE,MAAM;EACtB,IAAIC,CAAC,GAAG,CAAC;EAET,OAAOA,CAAC,GAAGF,GAAG,EAAE;IACd,IAAI,CAACD,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,EAAE;MAAG;MAC/BA,CAAC,EAAE;IACL,CAAC,MAAM,IAAI,CAACH,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,EAAE;MAAG;MACtC,IACEA,CAAC,GAAG,CAAC,KAAKF,GAAG,IACb,CAACD,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,IAC5B,CAACH,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,CAAE;MAAA,EAC1B;QACA,OAAO,KAAK;MACd;MAEAA,CAAC,IAAI,CAAC;IACR,CAAC,MAAM,IAAI,CAACH,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,EAAE;MAAG;MACtC,IACEA,CAAC,GAAG,CAAC,IAAIF,GAAG,IACZ,CAACD,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,IAC5B,CAACH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,IAC5BH,GAAG,CAACG,CAAC,CAAC,KAAK,IAAI,IAAI,CAACH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI;MAAK;MACpDH,GAAG,CAACG,CAAC,CAAC,KAAK,IAAI,IAAI,CAACH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,CAAE;MAAA,EACjD;QACA,OAAO,KAAK;MACd;MAEAA,CAAC,IAAI,CAAC;IACR,CAAC,MAAM,IAAI,CAACH,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,EAAE;MAAG;MACtC,IACEA,CAAC,GAAG,CAAC,IAAIF,GAAG,IACZ,CAACD,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,IAC5B,CAACH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,IAC5B,CAACH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI,IAC5BH,GAAG,CAACG,CAAC,CAAC,KAAK,IAAI,IAAI,CAACH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,MAAM,IAAI;MAAK;MACpDH,GAAG,CAACG,CAAC,CAAC,KAAK,IAAI,IAAIH,GAAG,CAACG,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI,IAAIH,GAAG,CAACG,CAAC,CAAC,GAAG,IAAI,CAAE;MAAA,EACvD;QACA,OAAO,KAAK;MACd;MAEAA,CAAC,IAAI,CAAC;IACR,CAAC,MAAM;MACL,OAAO,KAAK;IACd;EACF;EAEA,OAAO,IAAI;AACb;AAEAC,MAAM,CAACC,OAAO,GAAGN,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}