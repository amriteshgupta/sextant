{"ast":null,"code":"/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar utils = require('./utils');\nvar extend = utils.extend;\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar crypto = require('crypto');\nvar WebSocketConnection = require('./WebSocketConnection');\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar protocolSeparators = ['(', ')', '<', '>', '@', ',', ';', ':', '\\\\', '\\\"', '/', '[', ']', '?', '=', '{', '}', ' ', String.fromCharCode(9)];\nvar excludedTlsOptions = ['hostname', 'port', 'method', 'path', 'headers'];\nfunction WebSocketClient(config) {\n  // Superclass Constructor\n  EventEmitter.call(this);\n\n  // TODO: Implement extensions\n\n  this.config = {\n    // 1MiB max frame size.\n    maxReceivedFrameSize: 0x100000,\n    // 8MiB max message size, only applicable if\n    // assembleFragments is true\n    maxReceivedMessageSize: 0x800000,\n    // Outgoing messages larger than fragmentationThreshold will be\n    // split into multiple fragments.\n    fragmentOutgoingMessages: true,\n    // Outgoing frames are fragmented if they exceed this threshold.\n    // Default is 16KiB\n    fragmentationThreshold: 0x4000,\n    // Which version of the protocol to use for this session.  This\n    // option will be removed once the protocol is finalized by the IETF\n    // It is only available to ease the transition through the\n    // intermediate draft protocol versions.\n    // At present, it only affects the name of the Origin header.\n    webSocketVersion: 13,\n    // If true, fragmented messages will be automatically assembled\n    // and the full message will be emitted via a 'message' event.\n    // If false, each frame will be emitted via a 'frame' event and\n    // the application will be responsible for aggregating multiple\n    // fragmented frames.  Single-frame messages will emit a 'message'\n    // event in addition to the 'frame' event.\n    // Most users will want to leave this set to 'true'\n    assembleFragments: true,\n    // The Nagle Algorithm makes more efficient use of network resources\n    // by introducing a small delay before sending small packets so that\n    // multiple messages can be batched together before going onto the\n    // wire.  This however comes at the cost of latency, so the default\n    // is to disable it.  If you don't need low latency and are streaming\n    // lots of small messages, you can change this to 'false'\n    disableNagleAlgorithm: true,\n    // The number of milliseconds to wait after sending a close frame\n    // for an acknowledgement to come back before giving up and just\n    // closing the socket.\n    closeTimeout: 5000,\n    // Options to pass to https.connect if connecting via TLS\n    tlsOptions: {}\n  };\n  if (config) {\n    var tlsOptions;\n    if (config.tlsOptions) {\n      tlsOptions = config.tlsOptions;\n      delete config.tlsOptions;\n    } else {\n      tlsOptions = {};\n    }\n    extend(this.config, config);\n    extend(this.config.tlsOptions, tlsOptions);\n  }\n  this._req = null;\n  switch (this.config.webSocketVersion) {\n    case 8:\n    case 13:\n      break;\n    default:\n      throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n  }\n}\nutil.inherits(WebSocketClient, EventEmitter);\nWebSocketClient.prototype.connect = function (requestUrl, protocols, origin, headers, extraRequestOptions) {\n  var self = this;\n  if (typeof protocols === 'string') {\n    if (protocols.length > 0) {\n      protocols = [protocols];\n    } else {\n      protocols = [];\n    }\n  }\n  if (!(protocols instanceof Array)) {\n    protocols = [];\n  }\n  this.protocols = protocols;\n  this.origin = origin;\n  if (typeof requestUrl === 'string') {\n    this.url = url.parse(requestUrl);\n  } else {\n    this.url = requestUrl; // in case an already parsed url is passed in.\n  }\n  if (!this.url.protocol) {\n    throw new Error('You must specify a full WebSocket URL, including protocol.');\n  }\n  if (!this.url.host) {\n    throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n  }\n  this.secure = this.url.protocol === 'wss:';\n\n  // validate protocol characters:\n  this.protocols.forEach(function (protocol) {\n    for (var i = 0; i < protocol.length; i++) {\n      var charCode = protocol.charCodeAt(i);\n      var character = protocol.charAt(i);\n      if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n        throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n      }\n    }\n  });\n  var defaultPorts = {\n    'ws:': '80',\n    'wss:': '443'\n  };\n  if (!this.url.port) {\n    this.url.port = defaultPorts[this.url.protocol];\n  }\n  var nonce = bufferAllocUnsafe(16);\n  for (var i = 0; i < 16; i++) {\n    nonce[i] = Math.round(Math.random() * 0xFF);\n  }\n  this.base64nonce = nonce.toString('base64');\n  var hostHeaderValue = this.url.hostname;\n  if (this.url.protocol === 'ws:' && this.url.port !== '80' || this.url.protocol === 'wss:' && this.url.port !== '443') {\n    hostHeaderValue += ':' + this.url.port;\n  }\n  var reqHeaders = {};\n  if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n    // Allow for additional headers to be provided when connecting via HTTPS\n    extend(reqHeaders, this.config.tlsOptions.headers);\n  }\n  if (headers) {\n    // Explicitly provided headers take priority over any from tlsOptions\n    extend(reqHeaders, headers);\n  }\n  extend(reqHeaders, {\n    'Upgrade': 'websocket',\n    'Connection': 'Upgrade',\n    'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n    'Sec-WebSocket-Key': this.base64nonce,\n    'Host': reqHeaders.Host || hostHeaderValue\n  });\n  if (this.protocols.length > 0) {\n    reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n  }\n  if (this.origin) {\n    if (this.config.webSocketVersion === 13) {\n      reqHeaders['Origin'] = this.origin;\n    } else if (this.config.webSocketVersion === 8) {\n      reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n    }\n  }\n\n  // TODO: Implement extensions\n\n  var pathAndQuery;\n  // Ensure it begins with '/'.\n  if (this.url.pathname) {\n    pathAndQuery = this.url.path;\n  } else if (this.url.path) {\n    pathAndQuery = '/' + this.url.path;\n  } else {\n    pathAndQuery = '/';\n  }\n  function handleRequestError(error) {\n    self._req = null;\n    self.emit('connectFailed', error);\n  }\n  var requestOptions = {\n    agent: false\n  };\n  if (extraRequestOptions) {\n    extend(requestOptions, extraRequestOptions);\n  }\n  // These options are always overridden by the library.  The user is not\n  // allowed to specify these directly.\n  extend(requestOptions, {\n    hostname: this.url.hostname,\n    port: this.url.port,\n    method: 'GET',\n    path: pathAndQuery,\n    headers: reqHeaders\n  });\n  if (this.secure) {\n    var tlsOptions = this.config.tlsOptions;\n    for (var key in tlsOptions) {\n      if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n        requestOptions[key] = tlsOptions[key];\n      }\n    }\n  }\n  var req = this._req = (this.secure ? https : http).request(requestOptions);\n  req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n    self._req = null;\n    req.removeListener('error', handleRequestError);\n    self.socket = socket;\n    self.response = response;\n    self.firstDataChunk = head;\n    self.validateHandshake();\n  });\n  req.on('error', handleRequestError);\n  req.on('response', function (response) {\n    self._req = null;\n    if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n      self.emit('httpResponse', response, self);\n      if (response.socket) {\n        response.socket.end();\n      }\n    } else {\n      var headerDumpParts = [];\n      for (var headerName in response.headers) {\n        headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n      }\n      self.failHandshake('Server responded with a non-101 status: ' + response.statusCode + ' ' + response.statusMessage + '\\nResponse Headers Follow:\\n' + headerDumpParts.join('\\n') + '\\n');\n    }\n  });\n  req.end();\n};\nWebSocketClient.prototype.validateHandshake = function () {\n  var headers = this.response.headers;\n  if (this.protocols.length > 0) {\n    this.protocol = headers['sec-websocket-protocol'];\n    if (this.protocol) {\n      if (this.protocols.indexOf(this.protocol) === -1) {\n        this.failHandshake('Server did not respond with a requested protocol.');\n        return;\n      }\n    } else {\n      this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n      return;\n    }\n  }\n  if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n    this.failHandshake('Expected a Connection: Upgrade header from the server');\n    return;\n  }\n  if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n    this.failHandshake('Expected an Upgrade: websocket header from the server');\n    return;\n  }\n  var sha1 = crypto.createHash('sha1');\n  sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n  var expectedKey = sha1.digest('base64');\n  if (!headers['sec-websocket-accept']) {\n    this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n    return;\n  }\n  if (headers['sec-websocket-accept'] !== expectedKey) {\n    this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n    return;\n  }\n\n  // TODO: Support extensions\n\n  this.succeedHandshake();\n};\nWebSocketClient.prototype.failHandshake = function (errorDescription) {\n  if (this.socket && this.socket.writable) {\n    this.socket.end();\n  }\n  this.emit('connectFailed', new Error(errorDescription));\n};\nWebSocketClient.prototype.succeedHandshake = function () {\n  var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n  connection.webSocketVersion = this.config.webSocketVersion;\n  connection._addSocketEventListeners();\n  this.emit('connect', connection);\n  if (this.firstDataChunk.length > 0) {\n    connection.handleSocketData(this.firstDataChunk);\n  }\n  this.firstDataChunk = null;\n};\nWebSocketClient.prototype.abort = function () {\n  if (this._req) {\n    this._req.abort();\n  }\n};\nmodule.exports = WebSocketClient;","map":{"version":3,"names":["utils","require","extend","util","EventEmitter","http","https","url","crypto","WebSocketConnection","bufferAllocUnsafe","protocolSeparators","String","fromCharCode","excludedTlsOptions","WebSocketClient","config","call","maxReceivedFrameSize","maxReceivedMessageSize","fragmentOutgoingMessages","fragmentationThreshold","webSocketVersion","assembleFragments","disableNagleAlgorithm","closeTimeout","tlsOptions","_req","Error","inherits","prototype","connect","requestUrl","protocols","origin","headers","extraRequestOptions","self","length","Array","parse","protocol","host","secure","forEach","i","charCode","charCodeAt","character","charAt","indexOf","defaultPorts","port","nonce","Math","round","random","base64nonce","toString","hostHeaderValue","hostname","reqHeaders","hasOwnProperty","Host","join","pathAndQuery","pathname","path","handleRequestError","error","emit","requestOptions","agent","method","key","req","request","on","handleRequestUpgrade","response","socket","head","removeListener","firstDataChunk","validateHandshake","eventEmitterListenerCount","end","headerDumpParts","headerName","push","failHandshake","statusCode","statusMessage","toLocaleLowerCase","sha1","createHash","update","expectedKey","digest","succeedHandshake","errorDescription","writable","connection","_addSocketEventListeners","handleSocketData","abort","module","exports"],"sources":["C:/Users/AMRITESH/OneDrive - Babu Banarasi Das National Institute of Technology and Management/Documents/Workspace/ReactJs/sextant/node_modules/websocket/lib/WebSocketClient.js"],"sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar utils = require('./utils');\nvar extend = utils.extend;\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar http = require('http');\nvar https = require('https');\nvar url = require('url');\nvar crypto = require('crypto');\nvar WebSocketConnection = require('./WebSocketConnection');\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\n\nvar protocolSeparators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\n\nvar excludedTlsOptions = ['hostname','port','method','path','headers'];\n\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    // TODO: Implement extensions\n\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n          tlsOptions = config.tlsOptions;\n          delete config.tlsOptions;\n        }\n        else {\n          tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n\n    this._req = null;\n    \n    switch (this.config.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n    }\n}\n\nutil.inherits(WebSocketClient, EventEmitter);\n\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    \n    if (typeof(protocols) === 'string') {\n        if (protocols.length > 0) {\n            protocols = [protocols];\n        }\n        else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n\n    if (typeof(requestUrl) === 'string') {\n        this.url = url.parse(requestUrl);\n    }\n    else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error('You must specify a full WebSocket URL, including protocol.');\n    }\n    if (!this.url.host) {\n        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n    }\n\n    this.secure = (this.url.protocol === 'wss:');\n\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for (var i=0; i < protocol.length; i ++) {\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n\n    var defaultPorts = {\n        'ws:': '80',\n        'wss:': '443'\n    };\n\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n\n    var nonce = bufferAllocUnsafe(16);\n    for (var i=0; i < 16; i++) {\n        nonce[i] = Math.round(Math.random()*0xFF);\n    }\n    this.base64nonce = nonce.toString('base64');\n\n    var hostHeaderValue = this.url.hostname;\n    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||\n        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {\n        hostHeaderValue += (':' + this.url.port);\n    }\n\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n      // Allow for additional headers to be provided when connecting via HTTPS\n      extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n      // Explicitly provided headers take priority over any from tlsOptions\n      extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        'Upgrade': 'websocket',\n        'Connection': 'Upgrade',\n        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n        'Sec-WebSocket-Key': this.base64nonce,\n        'Host': reqHeaders.Host || hostHeaderValue\n    });\n\n    if (this.protocols.length > 0) {\n        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders['Origin'] = this.origin;\n        }\n        else if (this.config.webSocketVersion === 8) {\n            reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n        }\n    }\n\n    // TODO: Implement extensions\n\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    }\n    else if (this.url.path) {\n        pathAndQuery = '/' + this.url.path;\n    }\n    else {\n        pathAndQuery = '/';\n    }\n\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit('connectFailed', error);\n    }\n\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: 'GET',\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for (var key in tlsOptions) {\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener('error', handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on('error', handleRequestError);\n\n    req.on('response', function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n            self.emit('httpResponse', response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        }\n        else {\n            var headerDumpParts = [];\n            for (var headerName in response.headers) {\n                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n            }\n            self.failHandshake(\n                'Server responded with a non-101 status: ' +\n                response.statusCode + ' ' + response.statusMessage +\n                '\\nResponse Headers Follow:\\n' +\n                headerDumpParts.join('\\n') + '\\n'\n            );\n        }\n    });\n    req.end();\n};\n\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n\n    if (this.protocols.length > 0) {\n        this.protocol = headers['sec-websocket-protocol'];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake('Server did not respond with a requested protocol.');\n                return;\n            }\n        }\n        else {\n            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n            return;\n        }\n    }\n\n    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n        this.failHandshake('Expected a Connection: Upgrade header from the server');\n        return;\n    }\n\n    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n        this.failHandshake('Expected an Upgrade: websocket header from the server');\n        return;\n    }\n\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var expectedKey = sha1.digest('base64');\n\n    if (!headers['sec-websocket-accept']) {\n        this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n        return;\n    }\n\n    if (headers['sec-websocket-accept'] !== expectedKey) {\n        this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n        return;\n    }\n\n    // TODO: Support extensions\n\n    this.succeedHandshake();\n};\n\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit('connectFailed', new Error(errorDescription));\n};\n\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n\n    this.emit('connect', connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\n\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\n\nmodule.exports = WebSocketClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}