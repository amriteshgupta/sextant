{"ast":null,"code":"/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = require('./utils').extend;\nvar utils = require('./utils');\nvar util = require('util');\nvar debug = require('debug')('websocket:server');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketRequest = require('./WebSocketRequest');\nvar WebSocketServer = function WebSocketServer(config) {\n  // Superclass Constructor\n  EventEmitter.call(this);\n  this._handlers = {\n    upgrade: this.handleUpgrade.bind(this),\n    requestAccepted: this.handleRequestAccepted.bind(this),\n    requestResolved: this.handleRequestResolved.bind(this)\n  };\n  this.connections = [];\n  this.pendingRequests = [];\n  if (config) {\n    this.mount(config);\n  }\n};\nutil.inherits(WebSocketServer, EventEmitter);\nWebSocketServer.prototype.mount = function (config) {\n  this.config = {\n    // The http server instance to attach to.  Required.\n    httpServer: null,\n    // 64KiB max frame size.\n    maxReceivedFrameSize: 0x10000,\n    // 1MiB max message size, only applicable if\n    // assembleFragments is true\n    maxReceivedMessageSize: 0x100000,\n    // Outgoing messages larger than fragmentationThreshold will be\n    // split into multiple fragments.\n    fragmentOutgoingMessages: true,\n    // Outgoing frames are fragmented if they exceed this threshold.\n    // Default is 16KiB\n    fragmentationThreshold: 0x4000,\n    // If true, the server will automatically send a ping to all\n    // clients every 'keepaliveInterval' milliseconds.  The timer is\n    // reset on any received data from the client.\n    keepalive: true,\n    // The interval to send keepalive pings to connected clients if the\n    // connection is idle.  Any received data will reset the counter.\n    keepaliveInterval: 20000,\n    // If true, the server will consider any connection that has not\n    // received any data within the amount of time specified by\n    // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n    // be dead, and will drop the connection.\n    // Ignored if keepalive is false.\n    dropConnectionOnKeepaliveTimeout: true,\n    // The amount of time to wait after sending a keepalive ping before\n    // closing the connection if the connected peer does not respond.\n    // Ignored if keepalive is false.\n    keepaliveGracePeriod: 10000,\n    // Whether to use native TCP keep-alive instead of WebSockets ping\n    // and pong packets.  Native TCP keep-alive sends smaller packets\n    // on the wire and so uses bandwidth more efficiently.  This may\n    // be more important when talking to mobile devices.\n    // If this value is set to true, then these values will be ignored:\n    //   keepaliveGracePeriod\n    //   dropConnectionOnKeepaliveTimeout\n    useNativeKeepalive: false,\n    // If true, fragmented messages will be automatically assembled\n    // and the full message will be emitted via a 'message' event.\n    // If false, each frame will be emitted via a 'frame' event and\n    // the application will be responsible for aggregating multiple\n    // fragmented frames.  Single-frame messages will emit a 'message'\n    // event in addition to the 'frame' event.\n    // Most users will want to leave this set to 'true'\n    assembleFragments: true,\n    // If this is true, websocket connections will be accepted\n    // regardless of the path and protocol specified by the client.\n    // The protocol accepted will be the first that was requested\n    // by the client.  Clients from any origin will be accepted.\n    // This should only be used in the simplest of cases.  You should\n    // probably leave this set to 'false' and inspect the request\n    // object to make sure it's acceptable before accepting it.\n    autoAcceptConnections: false,\n    // Whether or not the X-Forwarded-For header should be respected.\n    // It's important to set this to 'true' when accepting connections\n    // from untrusted clients, as a malicious client could spoof its\n    // IP address by simply setting this header.  It's meant to be added\n    // by a trusted proxy or other intermediary within your own\n    // infrastructure.\n    // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n    ignoreXForwardedFor: false,\n    // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n    parseCookies: true,\n    // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n    parseExtensions: true,\n    // The Nagle Algorithm makes more efficient use of network resources\n    // by introducing a small delay before sending small packets so that\n    // multiple messages can be batched together before going onto the\n    // wire.  This however comes at the cost of latency, so the default\n    // is to disable it.  If you don't need low latency and are streaming\n    // lots of small messages, you can change this to 'false'\n    disableNagleAlgorithm: true,\n    // The number of milliseconds to wait after sending a close frame\n    // for an acknowledgement to come back before giving up and just\n    // closing the socket.\n    closeTimeout: 5000\n  };\n  extend(this.config, config);\n  if (this.config.httpServer) {\n    if (!Array.isArray(this.config.httpServer)) {\n      this.config.httpServer = [this.config.httpServer];\n    }\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function (httpServer) {\n      httpServer.on('upgrade', upgradeHandler);\n    });\n  } else {\n    throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n  }\n};\nWebSocketServer.prototype.unmount = function () {\n  var upgradeHandler = this._handlers.upgrade;\n  this.config.httpServer.forEach(function (httpServer) {\n    httpServer.removeListener('upgrade', upgradeHandler);\n  });\n};\nWebSocketServer.prototype.closeAllConnections = function () {\n  this.connections.forEach(function (connection) {\n    connection.close();\n  });\n  this.pendingRequests.forEach(function (request) {\n    process.nextTick(function () {\n      request.reject(503); // HTTP 503 Service Unavailable\n    });\n  });\n};\nWebSocketServer.prototype.broadcast = function (data) {\n  if (Buffer.isBuffer(data)) {\n    this.broadcastBytes(data);\n  } else if (typeof data.toString === 'function') {\n    this.broadcastUTF(data);\n  }\n};\nWebSocketServer.prototype.broadcastUTF = function (utfData) {\n  this.connections.forEach(function (connection) {\n    connection.sendUTF(utfData);\n  });\n};\nWebSocketServer.prototype.broadcastBytes = function (binaryData) {\n  this.connections.forEach(function (connection) {\n    connection.sendBytes(binaryData);\n  });\n};\nWebSocketServer.prototype.shutDown = function () {\n  this.unmount();\n  this.closeAllConnections();\n};\nWebSocketServer.prototype.handleUpgrade = function (request, socket) {\n  var self = this;\n  var wsRequest = new WebSocketRequest(socket, request, this.config);\n  try {\n    wsRequest.readHandshake();\n  } catch (e) {\n    wsRequest.reject(e.httpCode ? e.httpCode : 400, e.message, e.headers);\n    debug('Invalid handshake: %s', e.message);\n    this.emit('upgradeError', e);\n    return;\n  }\n  this.pendingRequests.push(wsRequest);\n  wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n  wsRequest.once('requestResolved', this._handlers.requestResolved);\n  socket.once('close', function () {\n    self._handlers.requestResolved(wsRequest);\n  });\n  if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n    this.emit('request', wsRequest);\n  } else if (this.config.autoAcceptConnections) {\n    wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n  } else {\n    wsRequest.reject(404, 'No handler is configured to accept the connection.');\n  }\n};\nWebSocketServer.prototype.handleRequestAccepted = function (connection) {\n  var self = this;\n  connection.once('close', function (closeReason, description) {\n    self.handleConnectionClose(connection, closeReason, description);\n  });\n  this.connections.push(connection);\n  this.emit('connect', connection);\n};\nWebSocketServer.prototype.handleConnectionClose = function (connection, closeReason, description) {\n  var index = this.connections.indexOf(connection);\n  if (index !== -1) {\n    this.connections.splice(index, 1);\n  }\n  this.emit('close', connection, closeReason, description);\n};\nWebSocketServer.prototype.handleRequestResolved = function (request) {\n  var index = this.pendingRequests.indexOf(request);\n  if (index !== -1) {\n    this.pendingRequests.splice(index, 1);\n  }\n};\nmodule.exports = WebSocketServer;","map":{"version":3,"names":["extend","require","utils","util","debug","EventEmitter","WebSocketRequest","WebSocketServer","config","call","_handlers","upgrade","handleUpgrade","bind","requestAccepted","handleRequestAccepted","requestResolved","handleRequestResolved","connections","pendingRequests","mount","inherits","prototype","httpServer","maxReceivedFrameSize","maxReceivedMessageSize","fragmentOutgoingMessages","fragmentationThreshold","keepalive","keepaliveInterval","dropConnectionOnKeepaliveTimeout","keepaliveGracePeriod","useNativeKeepalive","assembleFragments","autoAcceptConnections","ignoreXForwardedFor","parseCookies","parseExtensions","disableNagleAlgorithm","closeTimeout","Array","isArray","upgradeHandler","forEach","on","Error","unmount","removeListener","closeAllConnections","connection","close","request","process","nextTick","reject","broadcast","data","Buffer","isBuffer","broadcastBytes","toString","broadcastUTF","utfData","sendUTF","binaryData","sendBytes","shutDown","socket","self","wsRequest","readHandshake","e","httpCode","message","headers","emit","push","once","eventEmitterListenerCount","accept","requestedProtocols","origin","closeReason","description","handleConnectionClose","index","indexOf","splice","module","exports"],"sources":["C:/Users/AMRITESH/OneDrive - Babu Banarasi Das National Institute of Technology and Management/Documents/Workspace/ReactJs/sextant/node_modules/websocket/lib/WebSocketServer.js"],"sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = require('./utils').extend;\nvar utils = require('./utils');\nvar util = require('util');\nvar debug = require('debug')('websocket:server');\nvar EventEmitter = require('events').EventEmitter;\nvar WebSocketRequest = require('./WebSocketRequest');\n\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\n\nutil.inherits(WebSocketServer, EventEmitter);\n\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n\n        // If this is true, 'cookie' headers are parsed and exposed as WebSocketRequest.cookies\n        parseCookies: true,\n\n        // If this is true, 'sec-websocket-extensions' headers are parsed and exposed as WebSocketRequest.requestedExtensions\n        parseExtensions: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [this.config.httpServer];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on('upgrade', upgradeHandler);\n        });\n    }\n    else {\n        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n    }\n};\n\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener('upgrade', upgradeHandler);\n    });\n};\n\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n          request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\n\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    }\n    else if (typeof(data.toString) === 'function') {\n        this.broadcastUTF(data);\n    }\n};\n\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\n\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\n\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\n\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var self = this;\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    }\n    catch(e) {\n        wsRequest.reject(\n            e.httpCode ? e.httpCode : 400,\n            e.message,\n            e.headers\n        );\n        debug('Invalid handshake: %s', e.message);\n        this.emit('upgradeError', e);\n        return;\n    }\n\n    this.pendingRequests.push(wsRequest);\n\n    wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n    wsRequest.once('requestResolved', this._handlers.requestResolved);\n    socket.once('close', function () {\n        self._handlers.requestResolved(wsRequest);\n    });\n\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n        this.emit('request', wsRequest);\n    }\n    else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    }\n    else {\n        wsRequest.reject(404, 'No handler is configured to accept the connection.');\n    }\n};\n\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once('close', function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit('connect', connection);\n};\n\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit('close', connection, closeReason, description);\n};\n\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) { this.pendingRequests.splice(index, 1); }\n};\n\nmodule.exports = WebSocketServer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}