{"ast":null,"code":"/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar bufferUtil = require('bufferutil');\nvar bufferAllocUnsafe = require('./utils').bufferAllocUnsafe;\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n  this.maskBytes = maskBytes;\n  this.frameHeader = frameHeader;\n  this.config = config;\n  this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n  this.protocolError = false;\n  this.frameTooLarge = false;\n  this.invalidCloseFrameLength = false;\n  this.parseState = DECODE_HEADER;\n  this.closeStatus = -1;\n}\nWebSocketFrame.prototype.addData = function (bufferList) {\n  if (this.parseState === DECODE_HEADER) {\n    if (bufferList.length >= 2) {\n      bufferList.joinInto(this.frameHeader, 0, 0, 2);\n      bufferList.advance(2);\n      var firstByte = this.frameHeader[0];\n      var secondByte = this.frameHeader[1];\n      this.fin = Boolean(firstByte & 0x80);\n      this.rsv1 = Boolean(firstByte & 0x40);\n      this.rsv2 = Boolean(firstByte & 0x20);\n      this.rsv3 = Boolean(firstByte & 0x10);\n      this.mask = Boolean(secondByte & 0x80);\n      this.opcode = firstByte & 0x0F;\n      this.length = secondByte & 0x7F;\n\n      // Control frame sanity check\n      if (this.opcode >= 0x08) {\n        if (this.length > 125) {\n          this.protocolError = true;\n          this.dropReason = 'Illegal control frame longer than 125 bytes.';\n          return true;\n        }\n        if (!this.fin) {\n          this.protocolError = true;\n          this.dropReason = 'Control frames must not be fragmented.';\n          return true;\n        }\n      }\n      if (this.length === 126) {\n        this.parseState = WAITING_FOR_16_BIT_LENGTH;\n      } else if (this.length === 127) {\n        this.parseState = WAITING_FOR_64_BIT_LENGTH;\n      } else {\n        this.parseState = WAITING_FOR_MASK_KEY;\n      }\n    }\n  }\n  if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n    if (bufferList.length >= 2) {\n      bufferList.joinInto(this.frameHeader, 2, 0, 2);\n      bufferList.advance(2);\n      this.length = this.frameHeader.readUInt16BE(2);\n      this.parseState = WAITING_FOR_MASK_KEY;\n    }\n  } else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n    if (bufferList.length >= 8) {\n      bufferList.joinInto(this.frameHeader, 2, 0, 8);\n      bufferList.advance(8);\n      var lengthPair = [this.frameHeader.readUInt32BE(2), this.frameHeader.readUInt32BE(2 + 4)];\n      if (lengthPair[0] !== 0) {\n        this.protocolError = true;\n        this.dropReason = 'Unsupported 64-bit length frame received';\n        return true;\n      }\n      this.length = lengthPair[1];\n      this.parseState = WAITING_FOR_MASK_KEY;\n    }\n  }\n  if (this.parseState === WAITING_FOR_MASK_KEY) {\n    if (this.mask) {\n      if (bufferList.length >= 4) {\n        bufferList.joinInto(this.maskBytes, 0, 0, 4);\n        bufferList.advance(4);\n        this.parseState = WAITING_FOR_PAYLOAD;\n      }\n    } else {\n      this.parseState = WAITING_FOR_PAYLOAD;\n    }\n  }\n  if (this.parseState === WAITING_FOR_PAYLOAD) {\n    if (this.length > this.maxReceivedFrameSize) {\n      this.frameTooLarge = true;\n      this.dropReason = 'Frame size of ' + this.length.toString(10) + ' bytes exceeds maximum accepted frame size';\n      return true;\n    }\n    if (this.length === 0) {\n      this.binaryPayload = bufferAllocUnsafe(0);\n      this.parseState = COMPLETE;\n      return true;\n    }\n    if (bufferList.length >= this.length) {\n      this.binaryPayload = bufferList.take(this.length);\n      bufferList.advance(this.length);\n      if (this.mask) {\n        bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n        // xor(this.binaryPayload, this.maskBytes, 0);\n      }\n      if (this.opcode === 0x08) {\n        // WebSocketOpcode.CONNECTION_CLOSE\n        if (this.length === 1) {\n          // Invalid length for a close frame.  Must be zero or at least two.\n          this.binaryPayload = bufferAllocUnsafe(0);\n          this.invalidCloseFrameLength = true;\n        }\n        if (this.length >= 2) {\n          this.closeStatus = this.binaryPayload.readUInt16BE(0);\n          this.binaryPayload = this.binaryPayload.slice(2);\n        }\n      }\n      this.parseState = COMPLETE;\n      return true;\n    }\n  }\n  return false;\n};\nWebSocketFrame.prototype.throwAwayPayload = function (bufferList) {\n  if (bufferList.length >= this.length) {\n    bufferList.advance(this.length);\n    this.parseState = COMPLETE;\n    return true;\n  }\n  return false;\n};\nWebSocketFrame.prototype.toBuffer = function (nullMask) {\n  var maskKey;\n  var headerLength = 2;\n  var data;\n  var outputPos;\n  var firstByte = 0x00;\n  var secondByte = 0x00;\n  if (this.fin) {\n    firstByte |= 0x80;\n  }\n  if (this.rsv1) {\n    firstByte |= 0x40;\n  }\n  if (this.rsv2) {\n    firstByte |= 0x20;\n  }\n  if (this.rsv3) {\n    firstByte |= 0x10;\n  }\n  if (this.mask) {\n    secondByte |= 0x80;\n  }\n  firstByte |= this.opcode & 0x0F;\n\n  // the close frame is a special case because the close reason is\n  // prepended to the payload data.\n  if (this.opcode === 0x08) {\n    this.length = 2;\n    if (this.binaryPayload) {\n      this.length += this.binaryPayload.length;\n    }\n    data = bufferAllocUnsafe(this.length);\n    data.writeUInt16BE(this.closeStatus, 0);\n    if (this.length > 2) {\n      this.binaryPayload.copy(data, 2);\n    }\n  } else if (this.binaryPayload) {\n    data = this.binaryPayload;\n    this.length = data.length;\n  } else {\n    this.length = 0;\n  }\n  if (this.length <= 125) {\n    // encode the length directly into the two-byte frame header\n    secondByte |= this.length & 0x7F;\n  } else if (this.length > 125 && this.length <= 0xFFFF) {\n    // Use 16-bit length\n    secondByte |= 126;\n    headerLength += 2;\n  } else if (this.length > 0xFFFF) {\n    // Use 64-bit length\n    secondByte |= 127;\n    headerLength += 8;\n  }\n  var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n\n  // write the frame header\n  output[0] = firstByte;\n  output[1] = secondByte;\n  outputPos = 2;\n  if (this.length > 125 && this.length <= 0xFFFF) {\n    // write 16-bit length\n    output.writeUInt16BE(this.length, outputPos);\n    outputPos += 2;\n  } else if (this.length > 0xFFFF) {\n    // write 64-bit length\n    output.writeUInt32BE(0x00000000, outputPos);\n    output.writeUInt32BE(this.length, outputPos + 4);\n    outputPos += 8;\n  }\n  if (this.mask) {\n    maskKey = nullMask ? 0 : Math.random() * 0xFFFFFFFF >>> 0;\n    this.maskBytes.writeUInt32BE(maskKey, 0);\n\n    // write the mask key\n    this.maskBytes.copy(output, outputPos);\n    outputPos += 4;\n    if (data) {\n      bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n    }\n  } else if (data) {\n    data.copy(output, outputPos);\n  }\n  return output;\n};\nWebSocketFrame.prototype.toString = function () {\n  return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\nmodule.exports = WebSocketFrame;","map":{"version":3,"names":["bufferUtil","require","bufferAllocUnsafe","DECODE_HEADER","WAITING_FOR_16_BIT_LENGTH","WAITING_FOR_64_BIT_LENGTH","WAITING_FOR_MASK_KEY","WAITING_FOR_PAYLOAD","COMPLETE","WebSocketFrame","maskBytes","frameHeader","config","maxReceivedFrameSize","protocolError","frameTooLarge","invalidCloseFrameLength","parseState","closeStatus","prototype","addData","bufferList","length","joinInto","advance","firstByte","secondByte","fin","Boolean","rsv1","rsv2","rsv3","mask","opcode","dropReason","readUInt16BE","lengthPair","readUInt32BE","toString","binaryPayload","take","unmask","slice","throwAwayPayload","toBuffer","nullMask","maskKey","headerLength","data","outputPos","writeUInt16BE","copy","output","writeUInt32BE","Math","random","module","exports"],"sources":["C:/Users/AMRITESH/OneDrive - Babu Banarasi Das National Institute of Technology and Management/Documents/Workspace/ReactJs/sextant/node_modules/websocket/lib/WebSocketFrame.js"],"sourcesContent":["/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar bufferUtil = require('bufferutil');\nvar bufferAllocUnsafe = require('./utils').bufferAllocUnsafe;\n\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\n\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n\n            this.fin     = Boolean(firstByte  & 0x80);\n            this.rsv1    = Boolean(firstByte  & 0x40);\n            this.rsv2    = Boolean(firstByte  & 0x20);\n            this.rsv3    = Boolean(firstByte  & 0x10);\n            this.mask    = Boolean(secondByte & 0x80);\n\n            this.opcode  = firstByte  & 0x0F;\n            this.length = secondByte & 0x7F;\n\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = 'Illegal control frame longer than 125 bytes.';\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = 'Control frames must not be fragmented.';\n                    return true;\n                }\n            }\n\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            }\n            else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            }\n            else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n              this.frameHeader.readUInt32BE(2),\n              this.frameHeader.readUInt32BE(2+4)\n            ];\n\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = 'Unsupported 64-bit length frame received';\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        }\n        else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = 'Frame size of ' + this.length.toString(10) +\n                              ' bytes exceeds maximum accepted frame size';\n            return true;\n        }\n\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n                // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n\n            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n\n    firstByte |= (this.opcode & 0x0F);\n\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    }\n    else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    }\n    else {\n        this.length = 0;\n    }\n\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= (this.length & 0x7F);\n    }\n    else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n\n    outputPos = 2;\n\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n\n    if (this.mask) {\n        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n\n        if (data) {\n          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    }\n    else if (data) {\n        data.copy(output, outputPos);\n    }\n\n    return output;\n};\n\nWebSocketFrame.prototype.toString = function() {\n    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\n\n\nmodule.exports = WebSocketFrame;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}